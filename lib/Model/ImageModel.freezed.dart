// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'ImageModel.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SelectImageModel {
  Uint8List? get selectImageBytes => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SelectImageModelCopyWith<SelectImageModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SelectImageModelCopyWith<$Res> {
  factory $SelectImageModelCopyWith(
          SelectImageModel value, $Res Function(SelectImageModel) then) =
      _$SelectImageModelCopyWithImpl<$Res, SelectImageModel>;
  @useResult
  $Res call({Uint8List? selectImageBytes});
}

/// @nodoc
class _$SelectImageModelCopyWithImpl<$Res, $Val extends SelectImageModel>
    implements $SelectImageModelCopyWith<$Res> {
  _$SelectImageModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? selectImageBytes = freezed,
  }) {
    return _then(_value.copyWith(
      selectImageBytes: freezed == selectImageBytes
          ? _value.selectImageBytes
          : selectImageBytes // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SelectImageModelCopyWith<$Res>
    implements $SelectImageModelCopyWith<$Res> {
  factory _$$_SelectImageModelCopyWith(
          _$_SelectImageModel value, $Res Function(_$_SelectImageModel) then) =
      __$$_SelectImageModelCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Uint8List? selectImageBytes});
}

/// @nodoc
class __$$_SelectImageModelCopyWithImpl<$Res>
    extends _$SelectImageModelCopyWithImpl<$Res, _$_SelectImageModel>
    implements _$$_SelectImageModelCopyWith<$Res> {
  __$$_SelectImageModelCopyWithImpl(
      _$_SelectImageModel _value, $Res Function(_$_SelectImageModel) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? selectImageBytes = freezed,
  }) {
    return _then(_$_SelectImageModel(
      selectImageBytes: freezed == selectImageBytes
          ? _value.selectImageBytes
          : selectImageBytes // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
    ));
  }
}

/// @nodoc

class _$_SelectImageModel implements _SelectImageModel {
  const _$_SelectImageModel({this.selectImageBytes});

  @override
  final Uint8List? selectImageBytes;

  @override
  String toString() {
    return 'SelectImageModel(selectImageBytes: $selectImageBytes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SelectImageModel &&
            const DeepCollectionEquality()
                .equals(other.selectImageBytes, selectImageBytes));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(selectImageBytes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SelectImageModelCopyWith<_$_SelectImageModel> get copyWith =>
      __$$_SelectImageModelCopyWithImpl<_$_SelectImageModel>(this, _$identity);
}

abstract class _SelectImageModel implements SelectImageModel {
  const factory _SelectImageModel({final Uint8List? selectImageBytes}) =
      _$_SelectImageModel;

  @override
  Uint8List? get selectImageBytes;
  @override
  @JsonKey(ignore: true)
  _$$_SelectImageModelCopyWith<_$_SelectImageModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$EmbImageModel {
  Uint8List? get embImageBytes => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EmbImageModelCopyWith<EmbImageModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmbImageModelCopyWith<$Res> {
  factory $EmbImageModelCopyWith(
          EmbImageModel value, $Res Function(EmbImageModel) then) =
      _$EmbImageModelCopyWithImpl<$Res, EmbImageModel>;
  @useResult
  $Res call({Uint8List? embImageBytes});
}

/// @nodoc
class _$EmbImageModelCopyWithImpl<$Res, $Val extends EmbImageModel>
    implements $EmbImageModelCopyWith<$Res> {
  _$EmbImageModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? embImageBytes = freezed,
  }) {
    return _then(_value.copyWith(
      embImageBytes: freezed == embImageBytes
          ? _value.embImageBytes
          : embImageBytes // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_EmbImageModelCopyWith<$Res>
    implements $EmbImageModelCopyWith<$Res> {
  factory _$$_EmbImageModelCopyWith(
          _$_EmbImageModel value, $Res Function(_$_EmbImageModel) then) =
      __$$_EmbImageModelCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Uint8List? embImageBytes});
}

/// @nodoc
class __$$_EmbImageModelCopyWithImpl<$Res>
    extends _$EmbImageModelCopyWithImpl<$Res, _$_EmbImageModel>
    implements _$$_EmbImageModelCopyWith<$Res> {
  __$$_EmbImageModelCopyWithImpl(
      _$_EmbImageModel _value, $Res Function(_$_EmbImageModel) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? embImageBytes = freezed,
  }) {
    return _then(_$_EmbImageModel(
      embImageBytes: freezed == embImageBytes
          ? _value.embImageBytes
          : embImageBytes // ignore: cast_nullable_to_non_nullable
              as Uint8List?,
    ));
  }
}

/// @nodoc

class _$_EmbImageModel implements _EmbImageModel {
  const _$_EmbImageModel({this.embImageBytes});

  @override
  final Uint8List? embImageBytes;

  @override
  String toString() {
    return 'EmbImageModel(embImageBytes: $embImageBytes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EmbImageModel &&
            const DeepCollectionEquality()
                .equals(other.embImageBytes, embImageBytes));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(embImageBytes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_EmbImageModelCopyWith<_$_EmbImageModel> get copyWith =>
      __$$_EmbImageModelCopyWithImpl<_$_EmbImageModel>(this, _$identity);
}

abstract class _EmbImageModel implements EmbImageModel {
  const factory _EmbImageModel({final Uint8List? embImageBytes}) =
      _$_EmbImageModel;

  @override
  Uint8List? get embImageBytes;
  @override
  @JsonKey(ignore: true)
  _$$_EmbImageModelCopyWith<_$_EmbImageModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ExtStringModel {
  String? get extString => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ExtStringModelCopyWith<ExtStringModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExtStringModelCopyWith<$Res> {
  factory $ExtStringModelCopyWith(
          ExtStringModel value, $Res Function(ExtStringModel) then) =
      _$ExtStringModelCopyWithImpl<$Res, ExtStringModel>;
  @useResult
  $Res call({String? extString});
}

/// @nodoc
class _$ExtStringModelCopyWithImpl<$Res, $Val extends ExtStringModel>
    implements $ExtStringModelCopyWith<$Res> {
  _$ExtStringModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? extString = freezed,
  }) {
    return _then(_value.copyWith(
      extString: freezed == extString
          ? _value.extString
          : extString // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ExtStringModelCopyWith<$Res>
    implements $ExtStringModelCopyWith<$Res> {
  factory _$$_ExtStringModelCopyWith(
          _$_ExtStringModel value, $Res Function(_$_ExtStringModel) then) =
      __$$_ExtStringModelCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? extString});
}

/// @nodoc
class __$$_ExtStringModelCopyWithImpl<$Res>
    extends _$ExtStringModelCopyWithImpl<$Res, _$_ExtStringModel>
    implements _$$_ExtStringModelCopyWith<$Res> {
  __$$_ExtStringModelCopyWithImpl(
      _$_ExtStringModel _value, $Res Function(_$_ExtStringModel) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? extString = freezed,
  }) {
    return _then(_$_ExtStringModel(
      extString: freezed == extString
          ? _value.extString
          : extString // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_ExtStringModel implements _ExtStringModel {
  const _$_ExtStringModel({this.extString});

  @override
  final String? extString;

  @override
  String toString() {
    return 'ExtStringModel(extString: $extString)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ExtStringModel &&
            (identical(other.extString, extString) ||
                other.extString == extString));
  }

  @override
  int get hashCode => Object.hash(runtimeType, extString);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ExtStringModelCopyWith<_$_ExtStringModel> get copyWith =>
      __$$_ExtStringModelCopyWithImpl<_$_ExtStringModel>(this, _$identity);
}

abstract class _ExtStringModel implements ExtStringModel {
  const factory _ExtStringModel({final String? extString}) = _$_ExtStringModel;

  @override
  String? get extString;
  @override
  @JsonKey(ignore: true)
  _$$_ExtStringModelCopyWith<_$_ExtStringModel> get copyWith =>
      throw _privateConstructorUsedError;
}
